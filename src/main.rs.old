mod sub;
use std::rc::Rc;
use sub::Subst;

#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Exp {
    App(Box<Exp>, Box<Exp>),
    Lam(String, Box<Exp>),
    Let(String, Box<Exp>, Box<Exp>),
    Var(String),
}

use Exp::*;

fn substitute(x: &String, e: Box<Exp>, s: &Box<Exp>) -> Box<Exp> {
    match *e {
        App(e1, e2) => Box::new(App(substitute(x, e1, s), substitute(x, e2, s))),
        Lam(y, e) if y != *x => Box::new(Lam(y, substitute(x, e, s))),
        Let(y, e1, e2) if y != *x => Box::new(Let(y, substitute(x, e1, s), substitute(x, e2, s))),
        Var(y) if y == *x => s.clone(),
        _ => e,
    }
}

//fn reduce(e: Exp) -> Option<Exp> {
//    match e {
//        App(e1, e2) => {
//            if let Lam(x, e) = *e1 {
//            } else {
//                None
//            }
//        }
//        Lam(x, e) => {}
//        Let(x, e1, e2) => {
//            if let Some(e1) = reduce(*e1) {
//                Let(x, e1, e2)
//            } else {
//                Some(substitute(x, *e1, *e2))
//            }
//        }
//        Var(x) => None,
//    }
//}

//fn eval(e: Exp, env: Sub<Box<Exp>>) -> Option<Exp> {
//    match e {
//        App(e1, e2) => {
//            if let Lam(x, e) = *e1 {
//                let s = env.insert();
//            }
//            else
//            {
//                None
//            }
//        },
//        Lam(x, e) => {
//        },
//        Let(x, e1, e2) => {
//        },
//        Var(x) => x,
//    }
//}

fn reduce(e: Rc<Exp>, s: &Subst<Exp>) -> Option<Exp> {
    match e {
        App(e1, e2) => {
            if let Some(e2) = reduce(e2, &s) {
                Some(App(e1, Box::new(e2)))
            } else {
                if let Some(e1) = reduce(*e1, &s) {
                    Some(App(Box::new(e1), e2))
                } else {
                    if let Lam(x, e1) = *e1 {
                        let s = s.extend(x, *e2);
                        Some(s.apply(*e1))
                    } else {
                        None
                    }
                }
            }
        }
        Lam(x, e) => {
            if let App(e, y) = *e {
                if let Var(y) = *y {
                    if *x == y {
                        return Some(*e);
                    }
                }
            }
            None
        }
        Let(x, e1, e2) => {
            if let Some(e1) = reduce(*e1, &s) {
                Some(App(Box::new(e1), e2))
            } else {
                if let Some(e2) = reduce(*e2, &s) {
                    Some(App(e1, Box::new(e2)))
                } else {
                    let s = s.extend(x, *e1);
                    Some(s.apply(*e2))
                }
            }
        }
        e @ Var(_) => Some(s.apply(e)),
    }
}

fn main() {
    // let x = String::from("x");
    // let y = String::from("y");
    // let z = String::from("z");

    // let e = Box::new(Let(
    //     y.clone(),
    //     Box::new(App(
    //         Box::new(Lam(x.clone(), Box::new(Var(x.clone())))),
    //         Box::new(Var(z.clone())),
    //     )),
    //     Box::new(Var(z.clone())),
    // ));
    // let s = Box::new(App(
    //     Box::new(Var(x.clone())),
    //     Box::new(Var(String::from("sus"))),
    // ));

    let s = Subst::new();
    let mut e = Var(String::from("a"));

    while let Some(t) = reduce(Rc::new(e), &s) {
        e = t;
        println!("{:?}", e)
    }
}
